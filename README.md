# avito-autumn-2025

## Инструкция по запуску

### 1. Установка зависимостей
Перед запуском убедитесь, что на машине установлены:
- Docker
- Docker Compose
- GNU Make
---
### 2. Запуск Docker
Перед стартом сервиса необходимо поднять инфраструктуру — в первую очередь Docker.
Если Docker не запущен — запустите его вручную.

---
### 3. Запуск проекта
После того как Docker запущен, выполните:
`make compose-up`

Эта команда:
- поднимет PostgreSQL,
- соберёт контейнер приложения,
- запустит сервис в фоне.

После запуска API будет доступно по адресу:
http://localhost:8080
- другой порт можно указать в .env
---
### 4. Полная пересборка с регенерацией OpenAPI
Если вы обновили openapi.yml или код:
`make compose-rebuild`
Эта команда:
- Выполнит генерацию: `oapi_models; oapi_server; oapi_client`
- Пересоберёт контейнеры
- Запустит проект заново
---
### 5. Остановка проекта
`make compose-down`
Останавливает контейнеры и освобождает порты.

--- 
## Мои подводные камни:
### Вопросы, с которыми я столкнулся
#### 1. Обработка случая, когда у пользователя нет назначенных PR

**Контекст.**  
Метод `GetByUserID` в репозитории для Pull Request должен возвращать список PR, назначенных конкретному пользователю. 

**Вопрос:**  
Что делать, если строк в БД нет — возвращать ошибку или пустой список?

**Решение.**  
Я решил возвращать **пустой слайс без ошибки**:

- если запрос в БД завершился успешно, но строк нет — это валидная ситуация, пользователь просто не является ревьювером ни в одном PR;
- `nil` + `ErrNotFound` оставил для случаев, когда не найден конкретный объект по ID (например, `GetByID`).

Такой подход упрощает работу хендлеров и клиента API: отсутствие PR не считается ошибкой.

---

#### 2. Может ли пользователь быть одновременно в нескольких командах?

**Контекст.**  
В текущей версии системы (соответствующей требованиям) пользователь добавляется в систему, только внутри состава команды.

**Вопрос.**  
Что будет, если попытаться создать новую команду, но использовать старых пользователей?

**Решение.**  
Это вполне реально в бизнес контексте, но я не стал это обрабатывать, потому что это ломает код и мне надоело делать тестовое.

---

#### 3. Нужно ли убирать пользователя из AssignedReviewers, если он стал неактивным?

**Контекст.**  
Обрабатываем ручку **/users/setIsActive** со значением false для какого-либо пользователя.

**Вопрос.**  
Убирать его из Pull Requests со статусом OPEN?

**Решение.**  
Принято решение не убирать его из активных PR, а новые добавить не получится.

---

### Проблемы  

#### 1. Организация слоёв и транзакций (usecase / repository / txmanager)

**Проблема.**  
Нужно было реализовать транзакционность так, чтобы:
- репозитории оставались максимально простыми и не знали о бизнес-логике;
- usecase мог объединять несколько вызовов репозиториев в одну атомарную операцию;
- при этом не привязываться жёстко к конкретной реализации БД.

**Решение.**  
Я ввёл интерфейс `TxManager`, который принимает `context.Context` и функцию, а внутри уже открывает/коммитит/ролбечит транзакцию `sqlx.Tx`.  
Репозитории умеют работать и с `*sqlx.DB`, и с `*sqlx.Tx` через абстракцию `executor` (интерфейс с методами `GetContext`, `SelectContext`, `ExecContext`).  
В usecase я вызываю `txManager.Do(ctx, func(ctx context.Context) error { ... })` и внутри работаю только через репозитории — так достигается атомарность без протаскивания транзакций по всему коду.

---

#### 2. Идемпотентность операции Merge PR

**Проблема.**  
По заданию операция `Merge` должна быть идемпотентной: повторный вызов не должен ломать логику и не должен лишний раз ходить в БД, если статус уже `MERGED`.

**Решение.**  
В доменной модели `PullRequest` есть метод `Merge()`, который сам решает, можно ли менять статус.  
В usecase я делаю так:

1. Читаю PR из репозитория.
2. Сохраняю старый статус в переменную.
3. Вызываю `pr.Merge()`.
4. Если статус не изменился — просто выхожу из usecase без дополнительного `UPDATE` в БД.
5. Если статус поменялся — вызываю репозиторий для сохранения.

Таким образом, операция становится идемпотентной: повторный `Merge` над уже `MERGED` PR не приводит к дополнительным запросам обновления.

---

#### 3. Данные. Домен, Usecase DTO & Delivery DTO

**Проблема.**  
Нужно было решить, кто какие данные потребляет, как не связывать слои приложения между собой данными, которые они друг другу передают.

**Решение.**  
По примеру openapi я решил сделать **Input & Output** структуры для usecase, на основе доменных моделей.

Таким образом я оставил usecase «чистым» и возвращаю из него только DTO Output модели usecase слоя.

Конвертация DTO:

- хендлер вызывает usecase с его Input DTO;
- на выходе получает Output DTO;
- маппит её в сгенерированную OpenAPI-модель и отправляет клиенту.

Так HTTP-слой изолирован от домена через простой маппинг, а usecase не знает ни о каких `oapi.*` типах.

И usecase слой в свою очередь также изолирован от реализации delivery. У него есть свой независимый Input DTO

---

#### 4. Маппинг доменных ошибок в delivery-уровень

**Проблема.**  
При работе usecase возвращает ошибки доменного уровня.

В HTTP-слое нужно было:
- превратить их в корректные HTTP-коды,
- вернуть типизированный ErrorResponse, строго соответствующий OpenAPI (api.ErrorResponse),
- не писать длинные однотипные конструкции if err == ... в каждом хендлере.

Если делать это вручную в каждом обработчике, код превращается в огромные простыни проверок, нарушающие принцип single responsibility и ухудшающие читаемость.

**Решение.**  
Я вынес всю логику преобразования ошибок в одну функцию:
```go
func mapDomainErrorToErrorResponse(err error) (int, api.ErrorResponse) {
    ...
	switch {
	case errors.Is(err, domain.ErrUserExists):
		status = http.StatusConflict
		code = api.ErrorResponseErrorCode("USER EXISTS")
	default:
		status = http.StatusInternalServerError
		code = api.ErrorResponseErrorCode("INTERNAL_ERROR")
		err = errors.New("something went wrong")
	}
    ...
	return status, out

}
```

А в каждом хендлере достаточно одной строки:
```go
if err != nil {
	status, resp := mapDomainErrorToErrorResponse(err)
	if status == http.StatusInternalServerError {
		h.log.Error("internal error", "error", err)
	}
	c.JSON(status, resp)
	return
}
```

**Результат.**  
HTTP-слой стал полностью «тонким» и не содержит доменных проверок.
Все ошибки конвертируются централизованно, строго в соответствии с OpenAPI.

Код хендлеров стал линейным и компактным, без десятков if/else.
В одном месте легко поддерживать и расширять набор ошибок (удобно при ревью).

---
## Спасибо за тестовое, его было интересно делать!